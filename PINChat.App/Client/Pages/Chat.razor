@page "/Chat"
@attribute [Authorize]

@inject IJSRuntime JsRuntime
@inject ILoggedInUserModel LoggedInUser
@inject IUserEndpoint UserEndpoint
@inject IMessageEndpoint MessageEndpoint
@inject NavigationManager NavManager

<div class="view-wrapper">
    <div class="chat-view">
        <aside class="chat-sidebar">
            <div class="user-data-container">
                @* LoggedInUser Data *@
            
                <div class="d-flex justify-content-between">
                    <img class="img-avatar" src="resources/images/user-avatar.png" alt="User Avatar">
                    
                    <div class="d-flex">
                        <NavLink class="nav-link" href="/settings/user">
                            <image class="img-link" src="resources/images/Settings.png"></image>
                        </NavLink>
                        <NavLink class="nav-link" href="logout">
                            <image class="img-link" src="resources/images/Logout.png"></image>
                        </NavLink>
                    </div>
                </div>
                <h2>@LoggedInUser.DisplayName</h2>
                <h3>@LoggedInUser.FirstName @LoggedInUser.LastName</h3>
            </div>  
            
            <div class="friends-groups-container">
                <!-- Friends and Groups go here -->
                <h3>Kontakti</h3>
                <ul>
                    @foreach (var target in LoggedInUser.Contacts)
                    {
                        <li class="@ContactIsSelected(target.Id!)" @onclick="() => SetMessageTarget(target.Id!)">
                            @target.FirstName @target.LastName
                        </li>
                    }
                </ul>
                
                <h3>Grupe</h3>
                <ul>
                   @foreach (var target in LoggedInUser.Groups)
                   {
                       <li class="@ContactIsSelected(target.Id!)" @onclick="() => SetMessageTarget(target.Id!)">
                           @target.Name
                       </li>
                   }
                </ul>
            </div>
        </aside>
        
        <main class="chat-container">
            @if (!string.IsNullOrEmpty(_msgTarget) && _isMessageLoading)
            {
                <div class="loading-wrapper">
                    <div class="spinnerContainer">
                        <div class="spinner"></div>
                    </div>
                </div>
            }
            else
            {
                <div class="chat-output" @ref="_chatOutput">
                    @foreach (var message in _messages)
                    {
                        <div class="@($"{(message.IsOrigin ? "right" : "left")}-aligned message-container")">
                            <p class="date">@message.CreatedDate.ToLocalTime()</p>
                            <p class="message">@message.Content</p>
                        </div>
                    }
                </div>
            }

            <div class="chat-input">
                <input type="text" Placeholder="Nova poruka" @bind="_messageContent" @onkeydown="@(HandleKeyDown)">
                <button class="btn-accent" @onclick="SendMessage">Pošalji</button>
            </div>
        </main>
    </div>
</div>

@code {
    private ElementReference? _chatOutput;
    
    [CascadingParameter]
    public Task<AuthenticationState> AuthState { get; set; }
    
    HubConnection? _hubConnection;

    private string? _messageContent;
    private List<MessageModel> _messages = new();

    private string? _msgTarget = "";

    private bool _isMessageLoading;
    
    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthState;

        if (authState.User.Identity!.IsAuthenticated)
        {
            ConnectToHub();
        }
    }

    private async void ConnectToHub()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(NavManager.ToAbsoluteUri("/chathub"), options =>
            {
                options.AccessTokenProvider = () => Task.FromResult("YourAccessToken")!;
                options.Transports = HttpTransportType.WebSockets;
            })
            .WithAutomaticReconnect(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(5) })
            .Build();


        _hubConnection.On<string, MessageDtoModel>("ReceiveMessage", OnMessageReceived);
        await _hubConnection.StartAsync();
        await _hubConnection.InvokeAsync("Login", LoggedInUser.Id!);
    }

    private async Task OnMessageReceived(string action, MessageDtoModel message)
    {
        _isMessageLoading = true;
        
        var msg = new MessageModel(LoggedInUser)
        {
            CreatedDate = message.CreatedDate,
            TargetId = message.TargetId,
            SourceId = message.SourceId,
            Content = message.Content,
            Image = message.Image,
            IsOrigin = LoggedInUser.Id == message.SourceId
        };
    
        if (msg.SourceId == _msgTarget)
        {
            switch (action)
            {
                case "add":
                {
                    _messages.Add(msg);
                    // await ScrollToBottom();
                    StateHasChanged();   
                    break;
                }   
            }
        }
    }

    private async void SetMessageTarget(string targetId)
    {
        try
        {
            _msgTarget = targetId;
            _isMessageLoading = true;
            StateHasChanged();
            
            MessageQueryModel msgModel = new()
            {
                SourceId = LoggedInUser.Id,
                TargetId = targetId
            };

            _messages.Clear();
            _messages = await MessageEndpoint.GetById(msgModel);

            foreach (var msg in _messages)
            {
                msg.IsOrigin = LoggedInUser.Id == msg.SourceId;
            }
            StateHasChanged();
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
        finally
        {
            _isMessageLoading = false;
            StateHasChanged();
        }
    }
    
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key is "Enter")
        {
            await Task.Yield();
            
            if (!string.IsNullOrEmpty(_messageContent))
            {
                await SendMessage();
            }
        }
    }
    private async Task SendMessage()
    {
        if (string.IsNullOrEmpty(_msgTarget))
        {
            return;
        }
        
        try
        {
            var message = new MessageModel(LoggedInUser)
            {
                CreatedDate = DateTime.UtcNow,
                TargetId = _msgTarget,
                SourceId = LoggedInUser.Id,
                Content = _messageContent,
                Image = "",
                IsOrigin = true
            };
        
            _messages.Add(message);
            await _hubConnection!.SendAsync("MessageSingle", "add", message);

            await MessageEndpoint.CreateNew(message);
            
            _messageContent = "";

            // await ScrollToBottom();
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }

    }

    
    private string ContactIsSelected(string contactId)
    {
        return _msgTarget == contactId ? "selected" : "";
    }
    
    
    
    // private async Task ScrollToBottom()
    // {
    //     if (_chatOutput != null)
    //     {
    //         await JsRuntime.InvokeVoidAsync("blazorHelpers.scrollToBottom", _chatOutput);
    //     }
    // }
}